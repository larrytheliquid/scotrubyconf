may want to have specific example slides of lemmas with framework, and
unit tests in integration tests

===========================

narrowing conditions ("such that") to otherwise forall values as further dependent
parameters

================================

difference between reusing cucumber steps and a uni quant
function... semantics guaranteeing the forall is true, thus letting
you substitute your specific reuse case thanks to unification

=========

check opportunity to add or remove titles from slides (especially ones
with code)

=============================

should do a proof by contradiction

==========================
may want to just split the entire presentation in terms of implicit &
explicit proofs

=======================
make sure lemmas section answers the problem originally presented

================================

when mentioning curry-howard, can point back at the construction of a
sortedlist having the (implicit) proof embedded in it

=================
may want to show how any/dtpa proof-carrying-code can be used

==============================

maybe make specific headers for basic type implicit tests, implicit
function tests, and advanced type implicit tests... also coverage relates

=======================

possibly tweak the border between "coverage checking" & "implicit tests"

============================

show an example of an implicit tests via vectors... head solution
compared to checking for an empty array or first returing a 'nil'
default that must be checked dynamically again throughout the entire
program using this result

================================================

what is considered an integration test is relative

testing can come in shapes and sizes you might not expect
... implicit (using an abstraction, or specialized type) vs explicit
testing
... as rubyists we are used to doing mostly explicit testing, but we
also use abstractions to help ensure correctness without worrying
about it (rails, etc)... with a sufficiently advanced type system, a
particular datatype can be such an abstraction except have guaranteed
correctness properties visible in the type signature instead of
assumed ones by an object, a function, etc

maybe reference the beautiful membership->any->setoid->equivalence
... in other words the ability to encode math as you'd define it in a textbook

===========================================

monads for isolation of side effecting code from pure code is really
another form of implicit testing

prove inverse function

==========================

!SLIDE
# Ruby VS purely functional

    # Ruby
    Kernel#puts
    String#reverse!

    -- Agda
    putStr : String → IO ⊤
    reverse! : String → Monad String

<div style="display: none">

Ruby unrestricted mutation & metaprogramming... useful to write but
hard to reason about later

haskell-like purity... side-effects semantically restricted in type
signature via monads... this is not unique to dependent types,
e.g. haskell does the same

ruby uses ! convention to mark dangerous operations, and to a lesser
extent side effects

haskell instead uses language semantics to guarantee where side
effects can only possibly happen

can get a list of spots where a side-effect bug could have occurred
back... without this distinction testing/debugging is harder!

imagine how confusing a ? predicate method that mutates could
be... conventions are not enough
