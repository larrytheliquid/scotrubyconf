
monads for isolation of side effecting code from pure code is really
another form of implicit testing

==========================

maybe make specific headers for basic type implicit tests, implicit
function tests, and advanced type implicit tests... also coverage relates

=======================

possibly tweak the border between "coverage checking" & "implicit tests"

============================

show an example of an implicit tests via vectors... head solution
compared to checking for an empty array or first returing a 'nil'
default that must be checked dynamically again throughout the entire
program using this result

================================================


... could at this point introduce all problems and then solve each
one, or introduce/solve as i get to them, or introduce/preview-solve
and then in depth solve

... as much as we advocate testing, there are still many unsolved
problems in the area

ok... so coverage completeness drastically reduces runtime
errors... great, many less embarrassing 500 pages
you might expect that coverage completeness would just shift runtime
errors into logic errors... and indeed they normally would
... but these too can be prevented via preconditions... at compile
time, not runtime exceptions!

what is considered an integration test is relative

testing can come in shapes and sizes you might not expect
... implicit (using an abstraction, or specialized type) vs explicit
testing
... as rubyists we are used to doing mostly explicit testing, but we
also use abstractions to help ensure correctness without worrying
about it (rails, etc)... with a sufficiently advanced type system, a
particular datatype can be such an abstraction except have guaranteed
correctness properties visible in the type signature instead of
assumed ones by an object, a function, etc

- need to reveal what dependent types are:
1. no distinction between types & values wrt first-classiness
2. left-to-right dependency possible in types via labeling

maybe reference the beautiful membership->any->setoid->equivalence
... in other words the ability to encode math as you'd define it in a textbook

==========================================

start by show _*_ defined with _+_

move towards preconditions & explaining T, top & bottom


===========================================

!SLIDE
# Ruby VS purely functional

    # Ruby
    Kernel#puts
    String#reverse!

    -- Agda
    putStr : String → IO ⊤
    reverse! : String → Monad String

<div style="display: none">

Ruby unrestricted mutation & metaprogramming... useful to write but
hard to reason about later

haskell-like purity... side-effects semantically restricted in type
signature via monads... this is not unique to dependent types,
e.g. haskell does the same

ruby uses ! convention to mark dangerous operations, and to a lesser
extent side effects

haskell instead uses language semantics to guarantee where side
effects can only possibly happen

can get a list of spots where a side-effect bug could have occurred
back... without this distinction testing/debugging is harder!

imagine how confusing a ? predicate method that mutates could
be... conventions are not enough
