... could at this point introduce all problems and then solve each
one, or introduce/solve as i get to them, or introduce/preview-solve
and then in depth solve

... as much as we advocate testing, there are still many unsolved
problems in the area

if testing really is the answer, we have some problems to solve:

ok... so coverage completeness drastically reduces runtime
errors... great, many less embarrassing 500 pages
you might expect that coverage completeness would just shift runtime
errors into logic errors... and indeed they normally would
... but these too can be prevented via preconditions... at compile
time, not runtime exceptions!

what is considered an integration test is relative

testing can come in shapes and sizes you might not expect
... implicit (using an abstraction, or specialized type) vs explicit
testing
... as rubyists we are used to doing mostly explicit testing, but we
also use abstractions to help ensure correctness without worrying
about it (rails, etc)... with a sufficiently advanced type system, a
particular datatype can be such an abstraction except have guaranteed
correctness properties visible in the type signature instead of
assumed ones by an object, a function, etc

- need to reveal what dependent types are:
1. no distinction between types & values wrt first-classiness
2. left-to-right dependency possible in types via labeling

maybe reference the beautiful membership->any->setoid->equivalence
... in other words the ability to encode math as you'd define it in a textbook

==========================================

start by show _*_ defined with _+_

move towards preconditions & explaining T, top & bottom
