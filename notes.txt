
think about how combinatorial explosions relate to uni-quant

maybe link to now-private lemmachine github url

- maybe show an example of rack services interacting

====================
maybe mention stub method in lemmachine

====================

may want to have specific example slides of lemmas with framework, and
unit tests in integration tests

===========================

narrowing conditions ("such that") to otherwise forall values as further dependent
parameters

================================

difference between reusing cucumber steps and a uni quant
function... semantics guaranteeing the forall is true, thus letting
you substitute your specific reuse case thanks to unification

=========

check opportunity to add or remove titles from slides (especially ones
with code)

==========================
may want to just split the entire presentation in terms of implicit &
explicit proofs

=======================
make sure lemmas section answers the problem originally presented

================================

when mentioning curry-howard, can point back at the construction of a
sortedlist having the (implicit) proof embedded in it

==============================

maybe make specific headers for basic type implicit tests, implicit
function tests, and advanced type implicit tests... also coverage relates

=======================

possibly tweak the border between "coverage checking" & "implicit tests"

============================

what is considered an integration test is relative

testing can come in shapes and sizes you might not expect
... implicit (using an abstraction, or specialized type) vs explicit
testing
... as rubyists we are used to doing mostly explicit testing, but we
also use abstractions to help ensure correctness without worrying
about it (rails, etc)... with a sufficiently advanced type system, a
particular datatype can be such an abstraction except have guaranteed
correctness properties visible in the type signature instead of
assumed ones by an object, a function, etc

maybe reference the beautiful membership->any->setoid->equivalence
... in other words the ability to encode math as you'd define it in a textbook
